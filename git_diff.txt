diff --git a/Makefile b/Makefile
index e4465fc..193589c 100755
--- a/Makefile
+++ b/Makefile
@@ -42,8 +42,6 @@ warp:
 	cp src/boot/ksdk1.1.0/devIS25xP.*				build/ksdk1.1/work/demos/Warp/src/
 	cp src/boot/ksdk1.1.0/devAT45DB.*				build/ksdk1.1/work/demos/Warp/src/
 	cp src/boot/ksdk1.1.0/devICE40.*				build/ksdk1.1/work/demos/Warp/src/
-	cp src/boot/ksdk1.1.0/devSSD1331.*				build/ksdk1.1/work/demos/Warp/src/
-	cp src/boot/ksdk1.1.0/devINA219.*				build/ksdk1.1/work/demos/Warp/src/
 	cd build/ksdk1.1/work/lib/ksdk_platform_lib/armgcc/KL03Z4 && ./clean.sh; ./build_release.sh
 	cd build/ksdk1.1/work/demos/Warp/armgcc/Warp && ./clean.sh; ./build_release.sh
 	@echo "\n\nNow, run\n\n\tmake load-warp\n\n"
diff --git a/README.md b/README.md
index 8c4cf0f..2d33bbf 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,7 @@ This is the firmware for the [Warp hardware](https://github.com/physical-computa
 **Prerequisites:** You need an arm cross-compiler such as `arm-none-eabi-gcc` installed as well as a working `cmake` (installed, e.g., via `apt-get` on Linux or via [MacPorts](https://www.macports.org) on macOS). On Ubuntu, the package you need is `gcc-arm-none-eabi`. You will also need an installed copy of the SEGGER [JLink commander](https://www.segger.com/downloads/jlink/), `JlinkExe`, which is available for Linux, macOS, and Windows (here are direct links for downloading it for [macOS](https://www.segger.com/downloads/jlink/JLink_MacOSX.pkg), and [Linux tgz 64-bit](https://www.segger.com/downloads/jlink/JLink_Linux_x86_64.tgz)).
 
 ## 1.  Compiling the Warp firmware
-First, edit [setup.conf](setup.conf) to set the variable `ARMGCC_DIR` and `JLINKPATH`. If your `arm-none-eabi-gcc` is in `/usr/local/bin/arm-none-eabi-gcc`, then you want to set  `ARMGCC_DIR` to `/usr/local`. In the following, this `README.md` will refer to the top of the repository as `$TREEROOT`.
+First, edit [setup.conf](setup.conf) to set the variable `ARMGCC_DIR` and `JLINKPATH`. If your `arm-none-eabi-gcc` is in `/usr/local/bin/arm-none-eabi-gcc`, then you want to set  `ARMGCC_DIR` to `/usr/local`. In the following, this `README.md` will refer to the top of the repository as `$TREEROOT`. On some platforms, you might need to also, in addition, set the `ARMGCC_DIR` environment variable in your shell (using `setenv` or `export` as appropriate), to point to the same path as you set in [setup.conf](setup.conf).
 
 Second, edit [`tools/scripts/glaux.jlink.commands`](tools/scripts/glaux.jlink.commands) and [`tools/scripts/warp.jlink.commands`](tools/scripts/warp.jlink.commands) to replace `<full-path-to-warp-firmware>` with the full path to your Warp firmware directory.
 
diff --git a/build/ksdk1.1/build.sh b/build/ksdk1.1/build.sh
index 9548daf..667c1e6 100755
--- a/build/ksdk1.1/build.sh
+++ b/build/ksdk1.1/build.sh
@@ -1,7 +1,6 @@
 #!/bin/sh
 	
-	# Uncomment this to set ARMGCC_DIR correctly: 
-	export ARMGCC_DIR=/usr
+	# Uncomment this to set ARMGCC_DIR correctly: export ARMGCC_DIR=<full path to arm-gcc directory>
 
 	mkdir -p work
 	mkdir -p work/boards/Warp
@@ -33,8 +32,6 @@
 	cp ../../src/boot/ksdk1.1.0/devRV8803C7.*			work/demos/Warp/src/
 	cp ../../src/boot/ksdk1.1.0/devISL23415.*			work/demos/Warp/src/
 	cp ../../src/boot/ksdk1.1.0/devMAX11300.*			work/demos/Warp/src/
-	cp ../../src/boot/ksdk1.1.0/devSSD1331.*			work/demos/Warp/src/
-	cp ../../src/boot/ksdk1.1.0/devINA219.*				work/demos/Warp/src/
 	cp ../../src/boot/ksdk1.1.0/CMakeLists.txt			work/demos/Warp/armgcc/Warp/
 	cp ../../src/boot/ksdk1.1.0/startup_MKL03Z4.S			work/platform/startup/MKL03Z4/gcc/startup_MKL03Z4.S
 	cp ../../src/boot/ksdk1.1.0/gpio_pins.c				work/boards/Warp
diff --git a/setup.conf b/setup.conf
index 4c3d567..865c827 100644
--- a/setup.conf
+++ b/setup.conf
@@ -1,2 +1,2 @@
-JLINKPATH	=	"C:\Program Files\SEGGER\JLink\"
-ARMGCC_DIR	=	/usr
+JLINKPATH	=	<full path to JLink binary>
+ARMGCC_DIR	=	<full path to directory>
diff --git a/src/boot/README.md b/src/boot/README.md
index f105f23..e69de29 100644
--- a/src/boot/README.md
+++ b/src/boot/README.md
@@ -1,22 +0,0 @@
-## Project Overview
-The aim of this project was to use the Warp firmware as a base to create a device to measure and display rowing stroke rate using the FRDM-KL03Z development board.
-
-This readme is not intended to cover the entirety of the warp firmware; for information about building and running the Warp firmware see /README.md, and for information about the overall implementation see /src/boot/ksdk1.1.0/README.md. This readme is intended to cover the files and code used specifically to accomplish the aims of this project on top of the base firmware.
-
-The main logic for the rate meter is implemented in main() in /ksdk1.1.0/boot.c. There are three other components used in the project, one built in to the KL03Z and 2 external. The built in MMA8451Q digital accelerometer is used to measure the acceleration needed to indentify strokes. The SSD1331 OLED screen is used to display the output (the stroke rate). The INA219 current meter is used for analysis of power usage.
-
-### Source file descriptions
-##### 'boot.c'
-This is the core of the system, and main() contains the key logic for measuring rate.
-
-##### 'devMMA8451Q.c'
-This is the device driver for the accelerometer. I added a function to return the acceleration in just one axis in a more useable form to simplify the main algorithm.
-
-##### 'devSSD1331.c'
-This is the device driver for the OLED screen. I added functions to clear the screen, draw a rectangle, and draw numbers on a virtual 7 segment display.
-
-##### 'devINA219.c'
-This is the device driver for the current meter. I implemented this driver to provide a convenient way to read from the device.
-
-### Using the firmware
-Once the program is loaded onto the development board, using it is very simple. Connect the board to usb power (or 5V battery source) and wait for the screen to turn on. Oscillating the device in the X direction (parallel to the short side of the development board) will cause the OLED screen to display the rate (in 'strokes' per minute) that it is being oscillated at.
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/CMakeLists-Warp.txt b/src/boot/ksdk1.1.0/CMakeLists-Warp.txt
index 76404bb..4107e57 100755
--- a/src/boot/ksdk1.1.0/CMakeLists-Warp.txt
+++ b/src/boot/ksdk1.1.0/CMakeLists-Warp.txt
@@ -111,8 +111,6 @@ ADD_EXECUTABLE(Warp
     "${ProjDirPath}/../../src/devBGX.c"
     "${ProjDirPath}/../../src/devAS7262.c"
     "${ProjDirPath}/../../src/devAS7263.c"
-    "${ProjDirPath}/../../src/devSSD1331.c"
-    "${ProjDirPath}/../../src/devINA219.c"
 #   "${ProjDirPath}/../../src/devMAX11300.c
     "${ProjDirPath}/../../src/SEGGER_RTT.c"
     "${ProjDirPath}/../../src/SEGGER_RTT_printf.c"
diff --git a/src/boot/ksdk1.1.0/boot.c b/src/boot/ksdk1.1.0/boot.c
index d62045b..1789941 100755
--- a/src/boot/ksdk1.1.0/boot.c
+++ b/src/boot/ksdk1.1.0/boot.c
@@ -62,15 +62,11 @@
 #include "gpio_pins.h"
 #include "SEGGER_RTT.h"
 
-#include "devSSD1331.h"
-
 
 #define							kWarpConstantStringI2cFailure		"\rI2C failed, reg 0x%02x, code %d\n"
 #define							kWarpConstantStringErrorInvalidVoltage	"\rInvalid supply voltage [%d] mV!"
 #define							kWarpConstantStringErrorSanity		"\rSanity check failed!"
 
-#include "devINA219.h"
-volatile WarpI2CDeviceState deviceINA219State;
 
 #if (WARP_BUILD_ENABLE_DEVADXL362)
 	#include "devADXL362.h"
@@ -152,7 +148,7 @@ volatile WarpI2CDeviceState deviceINA219State;
 
 #if (WARP_BUILD_ENABLE_DEVCCS811)
 	#include "devCCS811.h"
-	volatile WarpI2CDeviceState			deviceCCS811State;
+	olatile WarpI2CDeviceState			deviceCCS811State;
 #endif
 
 #if (WARP_BUILD_ENABLE_DEVAMG8834)
@@ -1602,9 +1598,6 @@ main(void)
 	/*
 	 *	Initialize all the sensors
 	 */
-
-	initINA219( 0x40 );
-
 	#if (WARP_BUILD_ENABLE_DEVBMX055)
 		initBMX055accel(0x18	/* i2cAddress */,	&deviceBMX055accelState,	kWarpDefaultSupplyVoltageMillivoltsBMX055accel	);
 		initBMX055gyro(	0x68	/* i2cAddress */,	&deviceBMX055gyroState,		kWarpDefaultSupplyVoltageMillivoltsBMX055gyro	);
@@ -1613,7 +1606,7 @@ main(void)
 
 	#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
 //		initMMA8451Q(	0x1C	/* i2cAddress */,	&deviceMMA8451QState,		kWarpDefaultSupplyVoltageMillivoltsMMA8451Q	);
-		initMMA8451Q(	0x1D	/* i2cAddress */,		kWarpDefaultSupplyVoltageMillivoltsMMA8451Q	);
+		initMMA8451Q(	0x1C	/* i2cAddress */,		kWarpDefaultSupplyVoltageMillivoltsMMA8451Q	);
 	#endif
 
 	#if (WARP_BUILD_ENABLE_DEVLPS25H)
@@ -1876,19 +1869,6 @@ main(void)
 	gWarpBooted = true;
 	warpPrint("Boot done.\n");
 
-	devSSD1331init(); //Initialise OLED screen and turn it to plain green
-
-	writeINARegister(0x00, 0x01, 0x9F); //Write to configuration register
-	writeINARegister(0x05, 0x20, 0x00); //Write to calibration register
-
-	//Read 1000 values and print them in .csv format
-	/*for(int i = 0; i < 1000; i++){
-		uint8_t current = readINA(0x04, 2);
-		int16_t correctedValue = (((deviceINA219State.i2cBuffer[0] & 0xFF) << 8) | (deviceINA219State.i2cBuffer[1] & 0xFF))*50;
-		warpPrint("%d, \n", correctedValue);
-	}*/
-	writeSensorRegisterMMA8451Q(0x2A, 0x01);
-
 	#if (WARP_BUILD_BOOT_TO_CSVSTREAM)
 		printBootSplash(gWarpCurrentSupplyVoltage, menuRegisterAddress, &powerManagerCallbackStructure);
 
@@ -2037,106 +2017,765 @@ main(void)
 		}
 	#endif
 
-	writeINARegister(0x00, 0x01, 0x9F); //Write to configuration register
-	writeINARegister(0x05, 0x20, 0x00); //Write to calibration register
+	while (1)
+	{
+		/*
+		 *	Do not, e.g., lowPowerPinStates() on each iteration, because we actually
+		 *	want to use menu to progressiveley change the machine state with various
+		 *	commands.
+		 */
+		printBootSplash(gWarpCurrentSupplyVoltage, menuRegisterAddress, &powerManagerCallbackStructure);
 
-	//variables for rate calculations that persist between loops
-	int16_t values[50] = { 0 }; //stores accelerometer data
-	int16_t gaps[50] = { 0 }; //stores the time taken in each loop
-	int16_t previous_time = 0;
-	int current_first_digit = 0;
-	int current_second_digit = 0;
-	int current_third_digit = 0;
+		warpPrint("\rSelect:\n");
+		warpPrint("\r- 'a': set default sensor.\n");
+		warpPrint("\r- 'b': set I2C baud rate.\n");
+		warpPrint("\r- 'c': set SPI baud rate.\n");
+		warpPrint("\r- 'd': set UART baud rate.\n");
+		warpPrint("\r- 'e': set default register address.\n");
+		warpPrint("\r- 'f': write byte to sensor.\n");
+		warpPrint("\r- 'g': set default sensor supply voltage.\n");
+		warpPrint("\r- 'h': powerdown command to all sensors.\n");
+		warpPrint("\r- 'i': set pull-up enable value.\n");
+		warpPrint("\r- 'j': repeat read reg 0x%02x on sensor #%d.\n", menuRegisterAddress, menuTargetSensor);
+		warpPrint("\r- 'k': sleep until reset.\n");
+		warpPrint("\r- 'l': send repeated byte on I2C.\n");
+		warpPrint("\r- 'm': send repeated byte on SPI.\n");
+		warpPrint("\r- 'n': enable sensor supply voltage.\n");
+		warpPrint("\r- 'o': disable sensor supply voltage.\n");
+		warpPrint("\r- 'p': switch to VLPR mode.\n");
+		warpPrint("\r- 'r': switch to RUN mode.\n");
+		warpPrint("\r- 's': power up all sensors.\n");
+		warpPrint("\r- 't': dump processor state.\n");
+		warpPrint("\r- 'u': set I2C address.\n");
+
+		#if (WARP_BUILD_ENABLE_DEVAT45DB)
+			warpPrint("\r- 'R': read bytes from Flash.\n");
+			warpPrint("\r- 'F': write bytes to Flash.\n");
+		#endif
 
-	
+		#if (WARP_BUILD_ENABLE_DEVICE40)
+			warpPrint("\r- 'P': write bytes to FPGA configuration.\n");
+		#endif
 
-	while (1)
-	{
-		//Main loop: shifts data along, fetches new values, and analyses rate
-		int16_t x_val = getXVal();
+		#if (WARP_BUILD_ENABLE_DEVRV8803C7)
+			warpPrint("\r- 'v': Enter VLLS0 low-power mode for 3s, then reset\n");
+		#endif
 
-		int16_t current_time = OSA_TimeGetMsec();
-		int16_t elapsed_time = current_time - previous_time;
-		previous_time = current_time;
+		warpPrint("\r- 'x': disable SWD and spin for 10 secs.\n");
+		warpPrint("\r- 'z': perpetually dump all sensor data.\n");
 
-		for (int i = 0; i < 49; i++){ //shifts data along, making space for new data point and removing oldest
-			values[49-i] = values[48-i];
-		}
+		warpPrint("\rEnter selection> ");
+		key = warpWaitKey();
 
-		for (int i = 0; i < 48; i++){ //shifts data along, making space for new data point and removing oldest
-			gaps[49-i] = gaps[48-i];
-		}
+		switch (key)
+		{
+			/*
+			 *		Select sensor
+			 */
+			case 'a':
+			{
+				warpPrint("\r\tSelect:\n");
+
+				#if (WARP_BUILD_ENABLE_DEVADXL362)
+					warpPrint("\r\t- '1' ADXL362			(0x00--0x2D): 1.6V -- 3.5V\n");
+				#else
+					warpPrint("\r\t- '1' ADXL362			(0x00--0x2D): 1.6V -- 3.5V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVBMX055)
+					warpPrint("\r\t- '2' BMX055accel		(0x00--0x3F): 2.4V -- 3.6V\n");
+					warpPrint("\r\t- '3' BMX055gyro		(0x00--0x3F): 2.4V -- 3.6V\n");
+					warpPrint("\r\t- '4' BMX055mag			(0x40--0x52): 2.4V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '2' BMX055accel 		(0x00--0x3F): 2.4V -- 3.6V (compiled out) \n");
+					warpPrint("\r\t- '3' BMX055gyro			(0x00--0x3F): 2.4V -- 3.6V (compiled out) \n");
+					warpPrint("\r\t- '4' BMX055mag			(0x40--0x52): 2.4V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+					warpPrint("\r\t- '5' MMA8451Q			(0x00--0x31): 1.95V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '5' MMA8451Q			(0x00--0x31): 1.95V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVLPS25H)
+					warpPrint("\r\t- '6' LPS25H			(0x08--0x24): 1.7V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '6' LPS25H			(0x08--0x24): 1.7V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVMAG3110)
+					warpPrint("\r\t- '7' MAG3110			(0x00--0x11): 1.95V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '7' MAG3110			(0x00--0x11): 1.95V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVHDC1000)
+					warpPrint("\r\t- '8' HDC1000			(0x00--0x1F): 3.0V -- 5.0V\n");
+				#else
+					warpPrint("\r\t- '8' HDC1000			(0x00--0x1F): 3.0V -- 5.0V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVSI7021)
+					warpPrint("\r\t- '9' SI7021			(0x00--0x0F): 1.9V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- '9' SI7021			(0x00--0x0F): 1.9V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+					warpPrint("\r\t- 'a' L3GD20H			(0x0F--0x39): 2.2V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'a' L3GD20H			(0x0F--0x39): 2.2V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVBME680)
+					warpPrint("\r\t- 'b' BME680			(0xAA--0xF8): 1.6V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'b' BME680			(0xAA--0xF8): 1.6V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVTCS34725)
+					warpPrint("\r\t- 'd' TCS34725			(0x00--0x1D): 2.7V -- 3.3V\n");
+				#else
+					warpPrint("\r\t- 'd' TCS34725			(0x00--0x1D): 2.7V -- 3.3V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVSI4705)
+					warpPrint("\r\t- 'e' SI4705			(n/a):        2.7V -- 5.5V\n");
+				#else
+					warpPrint("\r\t- 'e' SI4705			(n/a):        2.7V -- 5.5V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVCCS811)
+					warpPrint("\r\t- 'g' CCS811			(0x00--0xFF): 1.8V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'g' CCS811			(0x00--0xFF): 1.8V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVAMG8834)
+					warpPrint("\r\t- 'h' AMG8834			(0x00--?): 3.3V -- 3.3V\n");
+				#else
+					warpPrint("\r\t- 'h' AMG8834			(0x00--?): 3.3V -- 3.3V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVAS7262)
+					warpPrint("\r\t- 'j' AS7262			(0x00--0x2B): 2.7V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'j' AS7262			(0x00--0x2B): 2.7V -- 3.6V (compiled out) \n");
+				#endif
+
+				#if (WARP_BUILD_ENABLE_DEVAS7263)
+					warpPrint("\r\t- 'k' AS7263			(0x00--0x2B): 2.7V -- 3.6V\n");
+				#else
+					warpPrint("\r\t- 'k' AS7263			(0x00--0x2B): 2.7V -- 3.6V (compiled out) \n");
+				#endif
+
+				warpPrint("\r\tEnter selection> ");
+				key = warpWaitKey();
+
+				switch(key)
+				{
+					#if (WARP_BUILD_ENABLE_DEVADXL362)
+						case '1':
+						{
+							menuTargetSensor = kWarpSensorADXL362;
+
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVBMX055)
+						case '2':
+						{
+							menuTargetSensor = kWarpSensorBMX055accel;
+							menuI2cDevice = &deviceBMX055accelState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVBMX055)
+						case '3':
+						{
+							menuTargetSensor = kWarpSensorBMX055gyro;
+							menuI2cDevice = &deviceBMX055gyroState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVBMX055)
+						case '4':
+						{
+							menuTargetSensor = kWarpSensorBMX055mag;
+							menuI2cDevice = &deviceBMX055magState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVMMA8451Q)
+						case '5':
+						{
+							menuTargetSensor = kWarpSensorMMA8451Q;
+							menuI2cDevice = &deviceMMA8451QState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVLPS25H)
+						case '6':
+						{
+							menuTargetSensor = kWarpSensorLPS25H;
+							menuI2cDevice = &deviceLPS25HState;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVMAG3110)
+						case '7':
+						{
+							menuTargetSensor = kWarpSensorMAG3110;
+							menuI2cDevice = &deviceMAG3110State;
+							break;
+						}
+					#endif
+
+					#if (WARP_BUILD_ENABLE_DEVHDC1000)
+						case '8':
+						{
+							menuTargetSensor = kWarpSensorHDC1000;
+							menuI2cDevice = &deviceHDC1000State;
+							break;
+						}
+					#endif
 
-		values[0] = x_val;
-		gaps[0] = elapsed_time;
+#if (WARP_BUILD_ENABLE_DEVSI7021)
+					case '9':
+					{
+						menuTargetSensor = kWarpSensorSI7021;
+						menuI2cDevice = &deviceSI7021State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVL3GD20H)
+					case 'a':
+					{
+						menuTargetSensor = kWarpSensorL3GD20H;
+						menuI2cDevice = &deviceL3GD20HState;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVBME680)
+					case 'b':
+					{
+						menuTargetSensor = kWarpSensorBME680;
+						menuI2cDevice = &deviceBME680State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVTCS34725)
+					case 'd':
+					{
+						menuTargetSensor = kWarpSensorTCS34725;
+						menuI2cDevice = &deviceTCS34725State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVSI4705)
+					case 'e':
+					{
+						menuTargetSensor = kWarpSensorSI4705;
+						menuI2cDevice = &deviceSI4705State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVCCS811)
+					case 'g':
+					{
+						menuTargetSensor = kWarpSensorCCS811;
+						menuI2cDevice = &deviceCCS811State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVAMG8834)
+					case 'h':
+					{
+						menuTargetSensor = kWarpSensorAMG8834;
+						menuI2cDevice = &deviceAMG8834State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVAS7262)
+					case 'j':
+					{
+						menuTargetSensor = kWarpSensorAS7262;
+						menuI2cDevice = &deviceAS7262State;
+						break;
+					}
+#endif
+#if (WARP_BUILD_ENABLE_DEVAS7263)
+					case 'k':
+					{
+						menuTargetSensor = kWarpSensorAS7263;
+						menuI2cDevice = &deviceAS7263State;
+						break;
+					}
+#endif
+					default:
+					{
+						warpPrint("\r\tInvalid selection '%c' !\n", key);
+					}
+				}
+
+				break;
+			}
 
-		int16_t peaks[50] = { 0 }; //array to store location of the peaks in the data
+			/*
+			 *	Change default I2C baud rate
+			 */
+			case 'b':
+			{
+				warpPrint("\r\n\tSet I2C baud rate in kbps (e.g., '0001')> ");
+				gWarpI2cBaudRateKbps = read4digits();
 
-		//identifies peaks in the data by looking for points above a threshold value, with 2 lower values either side
-		//maybe try one value either side?
-		for (int i = 0; i < 46; i++){
-			if(values[i+2] > values[i] && values[i+2] > values[i+1] && values[i+2] > values[i+3] && values[i+2] > values[i+4] && values[i+2] > 500){
-				peaks[i+1] = 1;
+				/*
+				 *	Round 9999kbps to 10Mbps
+				 */
+				if (gWarpI2cBaudRateKbps == 9999)
+				{
+					gWarpI2cBaudRateKbps = 10000;
+				}
+
+				warpPrint("\r\n\tI2C baud rate set to %d kb/s", gWarpI2cBaudRateKbps);
+
+				break;
 			}
-		}
-		
-		float gap = 0;
-		int16_t time_gap = 0;
-
-		//iterates through the peaks data to determine the time gap between strokes and therefore the length of the stroke
-		for (int i = 0; i < 50; i++){
-			if(peaks[i] == 1){
-				for (int j = i + 1; j < 50; j++){
-					time_gap = time_gap + 200;
-					if(peaks[j] == 1){
-						gap = j - i;
-						j = 50;
-						i = 50;
+
+			/*
+			 *	Change default SPI baud rate
+			 */
+			case 'c':
+			{
+				warpPrint("\r\n\tSet SPI baud rate in kbps (e.g., '0001')> ");
+				gWarpSpiBaudRateKbps = read4digits();
+
+				/*
+				 *	Round 9999kbps to 10Mbps
+				 */
+				if (gWarpSpiBaudRateKbps == 9999)
+				{
+					gWarpSpiBaudRateKbps = 10000;
+				}
+
+				warpPrint("\r\n\tSPI baud rate: %d kb/s", gWarpSpiBaudRateKbps);
+
+				break;
+			}
+
+			/*
+			 *	Change default UART baud rate
+			 */
+			case 'd':
+			{
+				warpPrint("\r\n\tSet UART baud rate in kbps (e.g., '0001')> ");
+				gWarpUartBaudRateBps = read4digits();
+				warpPrint("\r\n\tUART baud rate: %d kb/s", gWarpUartBaudRateBps);
+
+				break;
+			}
+
+			/*
+			 *	Set register address for subsequent operations
+			 */
+			case 'e':
+			{
+				warpPrint("\r\n\tEnter 2-nybble register hex address (e.g., '3e')> ");
+				menuRegisterAddress = readHexByte();
+				warpPrint("\r\n\tEntered [0x%02x].\n\n", menuRegisterAddress);
+
+				break;
+			}
+
+			/*
+			 *	Write byte to sensor
+			 */
+			case 'f':
+			{
+				uint8_t		i2cAddress, payloadByte[1], commandByte[1];
+				i2c_status_t	i2cStatus;
+				WarpStatus	status;
+
+
+				USED(status);
+				warpPrint("\r\n\tEnter I2C addr. (e.g., '0f') or '99' for SPI > ");
+				i2cAddress = readHexByte();
+				warpPrint("\r\n\tEntered [0x%02x].\n", i2cAddress);
+
+				warpPrint("\r\n\tEnter hex byte to send (e.g., '0f')> ");
+				payloadByte[0] = readHexByte();
+				warpPrint("\r\n\tEntered [0x%02x].\n", payloadByte[0]);
+
+				if (i2cAddress == 0x99)
+				{
+#if (WARP_BUILD_ENABLE_DEVADXL362)
+					warpPrint("\r\n\tWriting [0x%02x] to SPI register [0x%02x]...\n", payloadByte[0], menuRegisterAddress);
+					status = writeSensorRegisterADXL362(	0x0A			/*	command == write register	*/,
+										menuRegisterAddress,
+										payloadByte[0]		/*	writeValue			*/,
+										1			/*	numberOfBytes			*/
+									);
+					if (status != kWarpStatusOK)
+					{
+						warpPrint("\r\n\tSPI write failed, error %d.\n\n", status);
+					}
+					#else
+					warpPrint("\r\n\tSPI write failed. ADXL362 Disabled");
+#endif
+				}
+				else
+				{
+					i2c_device_t slave =
+					{
+						.address = i2cAddress,
+						.baudRate_kbps = gWarpI2cBaudRateKbps
+					};
+
+					warpScaleSupplyVoltage(gWarpCurrentSupplyVoltage);
+					warpEnableI2Cpins();
+
+					commandByte[0] = menuRegisterAddress;
+					i2cStatus = I2C_DRV_MasterSendDataBlocking(
+											0 /* I2C instance */,
+											&slave,
+											commandByte,
+											1,
+											payloadByte,
+											1,
+											gWarpI2cTimeoutMilliseconds);
+					if (i2cStatus != kStatus_I2C_Success)
+					{
+						warpPrint("\r\n\tI2C write failed, error %d.\n\n", i2cStatus);
 					}
+					warpDisableI2Cpins();
 				}
+
+				/*
+				 *	NOTE: do not disable the supply here, because we typically want to build on the effect of this register write command.
+				 */
+
+				break;
 			}
-		}
 
-		float rate = 0.0f;
+			/*
+			 *	Configure default TPS62740 voltage
+			 */
+			case 'g':
+			{
+				warpPrint("\r\n\tOverride sensor supply voltage in mV (e.g., '1800')> ");
+				gWarpCurrentSupplyVoltage = read4digits();
+				warpPrint("\r\n\tOverride sensor supply voltage set to %d mV", gWarpCurrentSupplyVoltage);
 
-		if(gap > 1){ //only calculate rate if there is a positive gap
-			rate = 60000.0f/(gap*(float)elapsed_time);
-			//rate = 60000.0f/(float)time_gap;
-		}
+				break;
+			}
 
-		warpPrint("Rate = %d,", (int)rate);
-		//warpPrint("%d, ", elapsed_time);
-		clear_screen();
-		int hundred = (int)(rate/100) % 10;
-		int ten = (int)(rate/10) % 10;
-		int one = (int)rate % 10;
+			/*
+			 *	Activate low-power modes in all sensors.
+			 */
+			case 'h':
+			{
+				warpPrint("\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				activateAllLowPowerSensorModes(true /* verbose */);
 
-		if(one != current_third_digit){
-			draw_number(one, 2);
-			current_third_digit = one;
-		}
-		if(ten != current_second_digit && rate > 10){
-			draw_number(ten, 1);
-			current_second_digit = ten;
-		}
-		if(hundred != current_first_digit && rate > 100){
-			draw_number(hundred, 0);
-			current_first_digit = hundred;
-		}
-		/*draw_number(one, 2);
-		if(rate>10){
-			draw_number(ten, 1);
-		}
-		if(rate>100){
-			draw_number(hundred, 0);
-		}*/
+				break;
+			}
+
+			/*
+			 *	Start repeated read
+			 */
+			case 'j':
+			{
+				bool		autoIncrement, chatty;
+				int		spinDelay, repetitionsPerAddress, chunkReadsPerAddress;
+				int		adaptiveSssupplyMaxMillivolts;
+				uint8_t		referenceByte;
+
+				warpPrint("\r\n\tAuto-increment from base address 0x%02x? ['0' | '1']> ", menuRegisterAddress);
+				autoIncrement = warpWaitKey() - '0';
+
+				warpPrint("\r\n\tChunk reads per address (e.g., '1')> ");
+				chunkReadsPerAddress = warpWaitKey() - '0';
+
+				warpPrint("\r\n\tChatty? ['0' | '1']> ");
+				chatty = warpWaitKey() - '0';
+
+				warpPrint("\r\n\tInter-operation spin delay in milliseconds (e.g., '0000')> ");
+				spinDelay = read4digits();
 
-		//retrieve current in microamps
-		uint8_t current = readINA(0x04, 2);
-		int16_t correctedValue = (((deviceINA219State.i2cBuffer[0] & 0xFF) << 8) | (deviceINA219State.i2cBuffer[1] & 0xFF))*50;
-		warpPrint("Current = %d,", correctedValue);
+				warpPrint("\r\n\tRepetitions per address (e.g., '0000')> ");
+				repetitionsPerAddress = read4digits();
 
-		OSA_TimeDelay(100); //here to make the loop time more consistent (probably remove)
+				warpPrint("\r\n\tMaximum voltage for adaptive supply (e.g., '0000')> ");
+				adaptiveSssupplyMaxMillivolts = read4digits();
+
+				warpPrint("\r\n\tReference byte for comparisons (e.g., '3e')> ");
+				referenceByte = readHexByte();
+
+				warpPrint("\r\n\tRepeating dev%d @ 0x%02x, reps=%d, pull=%d, delay=%dms:\n\n",
+					menuTargetSensor, menuRegisterAddress, repetitionsPerAddress, spinDelay);
+
+				repeatRegisterReadForDeviceAndAddress(	menuTargetSensor /*warpSensorDevice*/,
+									menuRegisterAddress /*baseAddress */,
+									autoIncrement /*autoIncrement*/,
+									chunkReadsPerAddress,
+									chatty,
+									spinDelay,
+									repetitionsPerAddress,
+									gWarpCurrentSupplyVoltage,
+									adaptiveSssupplyMaxMillivolts,
+									referenceByte
+								);
+
+				break;
+			}
+
+			/*
+			 *	Sleep for 30 seconds.
+			 */
+			case 'k':
+			{
+				warpPrint("\r\n\tSleeping until system reset...\n");
+				sleepUntilReset();
+
+				break;
+			}
+
+			/*
+			 *	Send repeated byte on I2C or SPI
+			 */
+			case 'l':
+			case 'm':
+			{
+				uint8_t		outBuffer[1];
+				int		repetitions;
+
+				warpPrint("\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				warpPrint("\r\n\tByte to send (e.g., 'F0')> ");
+				outBuffer[0] = readHexByte();
+
+				warpPrint("\r\n\tRepetitions (e.g., '0000')> ");
+				repetitions = read4digits();
+
+				if (key == 'l')
+				{
+					warpPrint("\r\n\tSending %d repetitions of [0x%02x] on I2C, sensor supply voltage=%dmV\n\n",
+						repetitions, outBuffer[0], gWarpCurrentSupplyVoltage);
+					for (int i = 0; i < repetitions; i++)
+					{
+						writeByteToI2cDeviceRegister(0xFF, true /* sedCommandByte */, outBuffer[0] /* commandByte */, false /* sendPayloadByte */, 0 /* payloadByte */);
+					}
+				}
+				else
+				{
+					warpPrint("\r\n\tSending %d repetitions of [0x%02x] on SPI, sensor supply voltage=%dmV\n\n",
+						repetitions, outBuffer[0], gWarpCurrentSupplyVoltage);
+					for (int i = 0; i < repetitions; i++)
+					{
+						writeBytesToSpi(outBuffer /* payloadByte */, 1 /* payloadLength */);
+					}
+				}
+
+				break;
+			}
+
+
+			/*
+			 *	enable sensor supply voltage
+			 */
+			case 'n':
+			{
+				warpScaleSupplyVoltage(gWarpCurrentSupplyVoltage);
+				break;
+			}
+
+			/*
+			 *	disable SSSUPPLY
+			 */
+			case 'o':
+			{
+				warpDisableSupplyVoltage();
+				break;
+			}
+
+			/*
+			 *	Switch to VLPR
+			 */
+			case 'p':
+			{
+				status = warpSetLowPowerMode(kWarpPowerModeVLPR, 0 /* sleep seconds : irrelevant here */);
+				if ((status != kWarpStatusOK) && (status != kWarpStatusPowerTransitionErrorVlpr2Vlpr))
+				{
+					warpPrint("warpSetLowPowerMode(kWarpPowerModeVLPR, 0 /* sleep seconds : irrelevant here */)() failed...\n");
+				}
+
+				break;
+			}
+
+			/*
+			 *	Switch to RUN
+			 */
+			case 'r':
+			{
+				warpSetLowPowerMode(kWarpPowerModeRUN, 0 /* sleep seconds : irrelevant here */);
+				if (status != kWarpStatusOK)
+				{
+					warpPrint("warpSetLowPowerMode(kWarpPowerModeRUN, 0 /* sleep seconds : irrelevant here */)() failed...\n");
+				}
+
+				break;
+			}
+
+			/*
+			 *	Power up all sensors
+			 */
+			case 's':
+			{
+				warpPrint("\r\n\tNOTE: First power sensors and enable I2C\n\n");
+				powerupAllSensors();
+				break;
+			}
+
+			/*
+			 *	Dump processor state
+			 */
+			case 't':
+			{
+				dumpProcessorState();
+				break;
+			}
+
+			case 'u':
+			{
+				if (menuI2cDevice == NULL)
+				{
+					warpPrint("\r\n\tCannot set I2C address: First set the default I2C device.\n");
+				}
+				else
+				{
+					warpPrint("\r\n\tSet I2C address of the selected sensor(e.g., '1C')> ");
+					uint8_t address = readHexByte();
+					menuI2cDevice->i2cAddress = address;
+				}
+
+				break;
+			}
+#if (WARP_BUILD_ENABLE_DEVRV8803C7)
+			case 'v':
+			{
+				warpPrint("\r\n\tSleeping for 3 seconds, then resetting\n");
+				warpSetLowPowerMode(kWarpPowerModeVLLS0, 3 /* sleep seconds */);
+				if (status != kWarpStatusOK)
+				{
+					warpPrint("warpSetLowPowerMode(kWarpPowerModeVLLS0, 3 /* sleep seconds : irrelevant here */)() failed...\n");
+				}
+
+				warpPrint("\r\n\tThis should never happen...\n");
+
+				break;
+			}
+#endif
+			/*
+			 *	Simply spin for 10 seconds. Since the SWD pins should only be enabled when we are waiting for key at top of loop (or toggling after printf), during this time there should be no interference from the SWD.
+			 */
+			case 'x':
+			{
+				warpPrint("\r\n\tSpinning for 10 seconds...\n");
+				OSA_TimeDelay(10000);
+				warpPrint("\r\tDone.\n\n");
+
+				break;
+			}
+
+			/*
+			 *	Dump all the sensor data in one go
+			 */
+			case 'z':
+			{
+				bool		hexModeFlag;
+
+				warpPrint("\r\n\tHex or converted mode? ('h' or 'c')> ");
+				key = warpWaitKey();
+				hexModeFlag = (key == 'h' ? 1 : 0);
+
+				warpPrint("\r\n\tSet the time delay between each run in milliseconds (e.g., '1234')> ");
+				uint16_t	menuDelayBetweenEachRun = read4digits();
+				warpPrint("\r\n\tDelay between read batches set to %d milliseconds.\n\n", menuDelayBetweenEachRun);
+				printAllSensors(true /* printHeadersAndCalibration */, hexModeFlag, menuDelayBetweenEachRun, true /* loopForever */);
+
+				/*
+				 *	Not reached (printAllSensors() does not return)
+				 */
+				warpDisableI2Cpins();
+
+				break;
+			}
+
+			/*
+			 *	Read bytes from Flash and print as hex
+			 */
+			case 'R':
+			{
+				warpPrint("\r\n\tStart address (e.g., '0000')> ");
+				//xx = read4digits();
+
+				warpPrint("\r\n\tEnd address (e.g., '0000')> ");
+				//xx = read4digits();
+
+				break;
+			}
+
+			/*
+			 *	Write raw bytes read from console to Flash
+			 */
+			case 'F':
+			{
+				warpPrint("\r\n\tStart address (e.g., '0000')> ");
+				//xx = read4digits();
+
+				warpPrint("\r\n\tNumber of bytes to read from console (e.g., '0000')> ");
+				//xx = read4digits();
+
+				warpPrint("\r\n\tEnter [%d] raw bytes > ");
+
+				break;
+			}
+
+			/*
+			 *	Use data from Flash to program FPGA
+			 */
+			case 'P':
+			{
+				warpPrint("\r\n\tStart address (e.g., '0000')> ");
+				//xx = read4digits();
+
+				warpPrint("\r\n\tNumber of bytes to use (e.g., '0000')> ");
+				//xx = read4digits();
+
+				break;
+			}
+
+
+			/*
+			 *	Ignore naked returns.
+			 */
+			case '\n':
+			{
+				warpPrint("\r\tPayloads make rockets more than just fireworks.");
+				break;
+			}
+
+			default:
+			{
+				warpPrint("\r\tInvalid selection '%c' !\n", key);
+			}
+		}
 	}
 
 	return 0;
@@ -3267,4 +3906,4 @@ activateAllLowPowerSensorModes(bool verbose)
 	#if (WARP_BUILD_ENABLE_DEVSI4705)
 		GPIO_DRV_ClearPinOutput(kWarpPinSI4705_nRST);
 	#endif
-}
\ No newline at end of file
+}
diff --git a/src/boot/ksdk1.1.0/config.h b/src/boot/ksdk1.1.0/config.h
index fb40d96..d76be6d 100644
--- a/src/boot/ksdk1.1.0/config.h
+++ b/src/boot/ksdk1.1.0/config.h
@@ -74,7 +74,7 @@
 	#define		WARP_BUILD_ENABLE_DEVL3GD20H		0
 	#define		WARP_BUILD_ENABLE_DEVLPS25H		0
 	#define		WARP_BUILD_ENABLE_DEVMAG3110		0
-	#define		WARP_BUILD_ENABLE_DEVMMA8451Q		1
+	#define		WARP_BUILD_ENABLE_DEVMMA8451Q		0
 	#define		WARP_BUILD_ENABLE_DEVRV8803C7		1
 	#define		WARP_BUILD_ENABLE_DEVSI4705		0
 	#define		WARP_BUILD_ENABLE_DEVSI7021		0
@@ -121,7 +121,7 @@
 	#define		WARP_BUILD_ENABLE_DEVL3GD20H		0
 	#define		WARP_BUILD_ENABLE_DEVLPS25H		0
 	#define		WARP_BUILD_ENABLE_DEVMAG3110		0
-	#define		WARP_BUILD_ENABLE_DEVMMA8451Q		1
+	#define		WARP_BUILD_ENABLE_DEVMMA8451Q		0
 	#define		WARP_BUILD_ENABLE_DEVRV8803C7		0
 	#define		WARP_BUILD_ENABLE_DEVSI4705		0
 	#define		WARP_BUILD_ENABLE_DEVSI7021		0
diff --git a/src/boot/ksdk1.1.0/devINA219.c b/src/boot/ksdk1.1.0/devINA219.c
deleted file mode 100644
index c0decdc..0000000
--- a/src/boot/ksdk1.1.0/devINA219.c
+++ /dev/null
@@ -1,114 +0,0 @@
-#include <stdlib.h>
-
-#include "config.h"
-
-#include "fsl_misc_utilities.h"
-#include "fsl_device_registers.h"
-#include "fsl_i2c_master_driver.h"
-#include "fsl_spi_master_driver.h"
-#include "fsl_rtc_driver.h"
-#include "fsl_clock_manager.h"
-#include "fsl_power_manager.h"
-#include "fsl_mcglite_hal.h"
-#include "fsl_port_hal.h"
-
-#include "gpio_pins.h"
-#include "SEGGER_RTT.h"
-#include "warp.h"
-
-extern volatile WarpI2CDeviceState	deviceINA219State;
-extern volatile uint32_t		gWarpI2cBaudRateKbps;
-extern volatile uint32_t		gWarpI2cTimeoutMilliseconds;
-
-void
-initINA219(const uint8_t i2cAddress)
-{
-	deviceINA219State.i2cAddress			= i2cAddress;
-
-	return;
-}
-
-void
-writeINARegister(uint8_t deviceRegister, uint8_t payload1, uint8_t payload2)
-{
-    uint8_t		payloadByte[2], commandByte[1];
-	i2c_status_t	status;
-
-	i2c_device_t slave =
-	{
-		.address = 0x40,
-		.baudRate_kbps = gWarpI2cBaudRateKbps
-	};
-
-	/* Write config register */
-	commandByte[0] = deviceRegister;
-	payloadByte[0] = payload1; //0x01
-	payloadByte[1] = payload2;
-	warpEnableI2Cpins();
-
-	status = I2C_DRV_MasterSendDataBlocking(
-							0 /* I2C instance */,
-							&slave,
-							commandByte,
-							1,
-							payloadByte,
-							2,
-							gWarpI2cTimeoutMilliseconds);
-
-	if (status != kStatus_I2C_Success)
-	{
-		warpPrint("Failed");
-		warpPrint("%x", status);
-	}
-}
-
-uint8_t
-readINA(uint8_t deviceRegister, int numberOfBytes)
-{
-    uint8_t		cmdBuf[1] = {0xFF};
-	i2c_status_t	status1, status;
-
-	USED(numberOfBytes);
-	i2c_device_t slave =
-	{
-		.address = deviceINA219State.i2cAddress,
-		.baudRate_kbps = gWarpI2cBaudRateKbps
-	};
-
-	cmdBuf[0] = deviceRegister;
-
-	warpEnableI2Cpins();
-
-	///warpPrint("Starting read");
-
-	status1 = I2C_DRV_MasterSendDataBlocking(
-							0 /* I2C peripheral instance */,
-							&slave,
-							cmdBuf,
-							1,
-							NULL,
-							0, /* replace with size of current buffer */
-							gWarpI2cTimeoutMilliseconds);
-
-	status = I2C_DRV_MasterReceiveDataBlocking(
-							0 /* I2C peripheral instance */,
-							&slave,
-							cmdBuf,
-							1,
-							(uint8_t *)deviceINA219State.i2cBuffer,
-							numberOfBytes, /* replace with size of current buffer */
-							gWarpI2cTimeoutMilliseconds);
-
-	if (status1 != kStatus_I2C_Success){
-		warpPrint("NULL write failed");
-		warpPrint("%x", status1);
-	}
-
-	if (status != kStatus_I2C_Success)
-	{
-		warpPrint("Failed");
-		warpPrint("%x", status);
-	}
-
-	return status;
-}
diff --git a/src/boot/ksdk1.1.0/devINA219.h b/src/boot/ksdk1.1.0/devINA219.h
deleted file mode 100644
index 3bac3f9..0000000
--- a/src/boot/ksdk1.1.0/devINA219.h
+++ /dev/null
@@ -1,3 +0,0 @@
-void initINA219(const uint8_t i2cAddress);
-void writeINARegister(uint8_t deviceRegister, uint8_t payload1, uint8_t payload2);
-uint8_t readINA(uint8_t deviceRegister, int numberOfBytes);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devMMA8451Q.c b/src/boot/ksdk1.1.0/devMMA8451Q.c
index f78c84f..187712d 100644
--- a/src/boot/ksdk1.1.0/devMMA8451Q.c
+++ b/src/boot/ksdk1.1.0/devMMA8451Q.c
@@ -205,27 +205,6 @@ readSensorRegisterMMA8451Q(uint8_t deviceRegister, int numberOfBytes)
 	return kWarpStatusOK;
 }
 
-int16_t getXVal()
-{
-	//Function to return just the X value from the accelerometer
-	uint16_t	readSensorRegisterValueLSB;
-	uint16_t	readSensorRegisterValueMSB;
-	int16_t		readSensorRegisterValueCombined;
-	WarpStatus	i2cReadStatus;
-
-
-	warpScaleSupplyVoltage(deviceMMA8451QState.operatingVoltageMillivolts);
-
-	i2cReadStatus = readSensorRegisterMMA8451Q(kWarpSensorOutputRegisterMMA8451QOUT_X_MSB, 2 /* numberOfBytes */);
-	readSensorRegisterValueMSB = deviceMMA8451QState.i2cBuffer[0]; //need two reads because the value is stored across two registers
-	readSensorRegisterValueLSB = deviceMMA8451QState.i2cBuffer[1];
-	readSensorRegisterValueCombined = ((readSensorRegisterValueMSB & 0xFF) << 6) | (readSensorRegisterValueLSB >> 2); //Combines most and least significant byte
-
-	readSensorRegisterValueCombined = (readSensorRegisterValueCombined ^ (1 << 13)) - (1 << 13);
-
-	return readSensorRegisterValueCombined;
-}
-
 void
 printSensorDataMMA8451Q(bool hexModeFlag)
 {
diff --git a/src/boot/ksdk1.1.0/devMMA8451Q.h b/src/boot/ksdk1.1.0/devMMA8451Q.h
index d696c3a..499c720 100644
--- a/src/boot/ksdk1.1.0/devMMA8451Q.h
+++ b/src/boot/ksdk1.1.0/devMMA8451Q.h
@@ -41,5 +41,4 @@ WarpStatus	readSensorRegisterMMA8451Q(uint8_t deviceRegister, int numberOfBytes)
 WarpStatus	writeSensorRegisterMMA8451Q(uint8_t deviceRegister,
 					uint8_t payloadBtye);
 WarpStatus	configureSensorMMA8451Q(uint8_t payloadF_SETUP, uint8_t payloadCTRL_REG1);
-void		printSensorDataMMA8451Q(bool hexModeFlag);
-int16_t		getXVal();
\ No newline at end of file
+void		printSensorDataMMA8451Q(bool hexModeFlag);
\ No newline at end of file
diff --git a/src/boot/ksdk1.1.0/devSSD1331.c b/src/boot/ksdk1.1.0/devSSD1331.c
index 6ed8802..7c4eb63 100644
--- a/src/boot/ksdk1.1.0/devSSD1331.c
+++ b/src/boot/ksdk1.1.0/devSSD1331.c
@@ -24,7 +24,7 @@ enum
 {
 	kSSD1331PinMOSI		= GPIO_MAKE_PIN(HW_GPIOA, 8),
 	kSSD1331PinSCK		= GPIO_MAKE_PIN(HW_GPIOA, 9),
-	kSSD1331PinCSn		= GPIO_MAKE_PIN(HW_GPIOB, 11),
+	kSSD1331PinCSn		= GPIO_MAKE_PIN(HW_GPIOB, 13),
 	kSSD1331PinDC		= GPIO_MAKE_PIN(HW_GPIOA, 12),
 	kSSD1331PinRST		= GPIO_MAKE_PIN(HW_GPIOB, 0),
 };
@@ -77,7 +77,7 @@ devSSD1331init(void)
 	PORT_HAL_SetMuxMode(PORTA_BASE, 8u, kPortMuxAlt3);
 	PORT_HAL_SetMuxMode(PORTA_BASE, 9u, kPortMuxAlt3);
 
-	warpEnableSPIpins();
+	enableSPIpins();
 
 	/*
 	 *	Override Warp firmware's use of these pins.
@@ -139,38 +139,21 @@ devSSD1331init(void)
 	writeCommand(kSSD1331CommandCONTRASTC);		// 0x83
 	writeCommand(0x7D);
 	writeCommand(kSSD1331CommandDISPLAYON);		// Turn on oled panel
-	//writeCommand(0xA5);
 
 	/*
 	 *	To use fill commands, you will have to issue a command to the display to enable them. See the manual.
 	 */
-
-	writeCommand(0x26); //enable filling
-	writeCommand(0xA1);
-	//writeCommand(kSSD1331CommandFILL);
-	//writeCommand(0x01);
-
-	writeCommand(0x22); //draw rectangle
-	writeCommand(0x00);
-	writeCommand(0x00);
-	writeCommand(0x7F);
-	writeCommand(0x3F);
-
-	writeCommand(0x00); //line colors
-	writeCommand(0xFF);
-	writeCommand(0x00);
-	writeCommand(0x00); //fill colors
-	writeCommand(0xFF);
-	writeCommand(0x00);
+	writeCommand(kSSD1331CommandFILL);
+	writeCommand(0x01);
 
 	/*
 	 *	Clear Screen
 	 */
-	//writeCommand(kSSD1331CommandCLEAR);
-	//writeCommand(0x00);
-	//writeCommand(0x00);
-	//writeCommand(0x5F);
-	//writeCommand(0x3F);
+	writeCommand(kSSD1331CommandCLEAR);
+	writeCommand(0x00);
+	writeCommand(0x00);
+	writeCommand(0x5F);
+	writeCommand(0x3F);
 
 
 
@@ -183,62 +166,3 @@ devSSD1331init(void)
 
 	return 0;
 }
-
-int draw_rectangle(int x_start, int y_start, int x_end, int y_end, int red, int blue, int green){
-	writeCommand(0x22); //draw rectangle
-	writeCommand(x_start);
-	writeCommand(y_start);
-	writeCommand(x_end);
-	writeCommand(y_end);
-
-	writeCommand(red); //line colors
-	writeCommand(green);
-	writeCommand(blue);
-	writeCommand(red); //fill colors
-	writeCommand(green);
-	writeCommand(blue);
-
-	return 0;
-}
-
-void draw_number(int number, int position){
-	/*function to draw the necessary lines on the seven segment display
-	to show the given number in the required position*/
-	if(number == 4 || number == 5 || number == 6 || number == 8 || number == 9 || number == 0){
-		draw_rectangle(6 + 29 * position, 10, 10 + 29 * position, 30, 255, 0, 0);
-	}
-	if(number == 2 || number == 3 || number == 5 || number == 6 || number == 7 || number == 8 || number == 9 || number == 0){
-		draw_rectangle(6 + 29 * position, 10, 26 + 29 * position, 14, 255, 0, 0);
-	}
-	if(number == 1 || number == 2 || number == 3 || number == 4 || number == 7 || number == 8 || number == 9 || number == 0){
-		draw_rectangle(26 + 29 * position, 10, 30 + 29 * position, 30, 255, 0, 0);
-	}
-	if(number == 1 || number == 3 || number == 4 || number == 5 || number == 6 || number == 7 || number == 8 || number == 9 || number == 0){
-		draw_rectangle(26 + 29 * position, 34, 30 + 29 * position, 54, 255, 0, 0);
-	}
-	if(number == 2 || number == 3 || number == 4 || number == 5 || number == 6 || number == 8 || number == 9){
-		draw_rectangle(6 + 29 * position, 30, 30 + 29 * position, 34, 255, 0, 0);
-	}
-	if(number == 2 || number == 6 || number == 8 || number == 0){
-		draw_rectangle(6 + 29 * position, 34, 10 + 29 * position, 54, 255, 0, 0);
-	}
-	if(number == 2 || number == 3 || number == 5 || number == 6 || number == 8 || number == 0){
-		draw_rectangle(6 + 29 * position, 50, 26 + 29 * position, 54, 255, 0, 0);
-	}
-}
-
-void clear_screen(){
-	//creates a blank screen by drawing a rectangle with the dimensions of the screen
-	writeCommand(0x22); //draw rectangle
-	writeCommand(0x00);
-	writeCommand(0x00);
-	writeCommand(0x7F);
-	writeCommand(0x3F);
-
-	writeCommand(0x00); //line colors
-	writeCommand(0xFF);
-	writeCommand(0x00);
-	writeCommand(0x00); //fill colors
-	writeCommand(0xFF);
-	writeCommand(0x00);
-}
diff --git a/src/boot/ksdk1.1.0/devSSD1331.h b/src/boot/ksdk1.1.0/devSSD1331.h
index ccf6c5d..0de5b34 100644
--- a/src/boot/ksdk1.1.0/devSSD1331.h
+++ b/src/boot/ksdk1.1.0/devSSD1331.h
@@ -43,6 +43,3 @@ typedef enum
 } SSD1331Commands;
 
 int	devSSD1331init(void);
-int draw_rectangle(int x_start, int y_start, int x_end, int y_end, int red, int blue, int green);
-void draw_number(int number, int position);
-void clear_screen(void);
diff --git a/src/boot/ksdk1.1.0/warp-kl03-ksdk1.1-boot.c b/src/boot/ksdk1.1.0/warp-kl03-ksdk1.1-boot.c
index 14a5273..01cff5f 100755
--- a/src/boot/ksdk1.1.0/warp-kl03-ksdk1.1-boot.c
+++ b/src/boot/ksdk1.1.0/warp-kl03-ksdk1.1-boot.c
@@ -56,7 +56,7 @@
 #include "warp.h"
 
 
-#define WARP_FRDMKL03
+//#define WARP_FRDMKL03
 
 
 /*
